# This script generates a Verilog module for a Pseudo-Random Binary Sequence (PRBS) generator based on a given polynomial.
import os
import numpy as np
import argparse

def generate_matrix_from_polynomial(coefficients, width):
    """
    Generate a matrix based on the given polynomial coefficients.
    
    Args:
        coefficients (list): Coefficients of the polynomial (e.g., [0, 0, 0, 0, 0, 1, 1] for x^7 + x^6 + 1).
        width (int): Width of the matrix.
    
    Returns:
        numpy.ndarray: Generated matrix.
    """
    n = len(coefficients)
    G = np.zeros((width, width), dtype=int)
    G[0, :n] = coefficients
    for i in range(1, width):
        G[i, i - 1] = 1
    return G

def matrix_mod2_multiply(matrix, times):
    """
    Perform cumulative matrix multiplication with mod-2 addition (XOR).
    
    Args:
        matrix (numpy.ndarray): Input square matrix.
        times (int): Number of cumulative multiplications to perform.
    
    Returns:
        numpy.ndarray: Resulting matrix after cumulative mod-2 multiplications.
    """
    n = matrix.shape[0]
    result = np.eye(n, dtype=int)
    for _ in range(times):
        result = np.mod(np.dot(result, matrix), 2)
    return result

def generate_verilog_from_matrix(matrix, module_name, coefficients,interations=1):
    """
    Generate Verilog code from a given matrix.

    Args:
        matrix (numpy.ndarray): Input matrix.
        module_name (str): Name of the Verilog module.
        coefficients (list): Coefficients of the polynomial.

    Returns:
        str: Generated Verilog code.
    """
    width = matrix.shape[0]
    n = len(coefficients)
    verilog_code = []
    verilog_code.append(f"//---------------------------------------------------------------------------------------")
    verilog_code.append(f"// this module is auto generated by prbs_verilog_gen.py")
    verilog_code.append(f"// Generated on: {np.datetime64('now', 's')}")
    verilog_code.append(f"// Description: Verilog module for PRBS{n} generator,this module is {interations} times shift result.")
    verilog_code.append(f"// Polynomial: 1 + {' + '.join(f'x^{i+1}' for i in range(n) if coefficients[i] == 1)}")
    verilog_code.append(f"// Width: {width}")
    verilog_code.append(f"// Iterations: {interations}")
    verilog_code.append(f"//--------------------------------------------------------------------------------------")
    verilog_code.append("")
    verilog_code.append(f"module {module_name} (")
    verilog_code.append(f"    input [{width-1}:0] din,")
    verilog_code.append(f"    output [{width-1}:0] dout")
    verilog_code.append(");")
    verilog_code.append("")
    for i in range(width):
        indices = [f"din[{j}]" for j in range(width) if matrix[i, j] == 1]
        if indices:
            verilog_code.append(f"    assign dout[{i}] = {' ^ '.join(indices)};")
        else:
            verilog_code.append(f"    assign dout[{i}] = 0;")
    verilog_code.append("")
    verilog_code.append("endmodule")
    return "\n".join(verilog_code)

"""
# Example usage
if __name__ == "__main__":
    # Polynomial: x^7 + x^6 + 1 -> coefficients: [0, 0, 0, 0, 0, 1, 1]
    coefficients = [0, 0, 0, 0, 0, 1, 1]
    width = 32
    times = 32
    G = generate_matrix_from_polynomial(coefficients, width)
    print("G matrix:")
    print(G)
    G_iteration =  matrix_mod2_multiply(G, times)
    print("G_iteration matrix:")
    print(G_iteration)  
    # Generate Verilog code
    n = len(coefficients)
    module_name = "prbs" + str(n) + "_width" + str(width) + "_iter" + str(times)
    verilog_code = generate_verilog_from_matrix(G_iteration, module_name,coefficients)
    #save to file
    with open(module_name + ".v", "w") as f:
        f.write(verilog_code)
    # Print the Verilog code    
    print(verilog_code)
"""


def main():
    parser = argparse.ArgumentParser(description="Generate a Verilog module for a PRBS generator.")
    parser.add_argument("-c", "--coefficients", type=str, required=True, 
                        help="Polynomial coefficients as a comma-separated list (e.g., '0,0,0,0,0,1,1' for x^7 + x^6 + 1).")
    parser.add_argument("-w", "--width", type=int, required=True, help="Width of the matrix.")
    parser.add_argument("-t", "--times", type=int, required=True, help="Number of cumulative multiplications.")
    parser.add_argument("-o", "--output", type=str, default=".", 
                        help="Output directory to save the Verilog file (default: current directory).")
    parser.add_argument("-s", "--suffix", type=str, default=None, 
                        help="Optional suffix to include in the module name for distinguishing different polynomials.")
    
    args = parser.parse_args()
    
    coefficients = list(map(int, args.coefficients.split(',')))
    G = generate_matrix_from_polynomial(coefficients, args.width)
    print("G matrix:")
    print(G)
    
    G_iteration = matrix_mod2_multiply(G, args.times)
    print("G_iteration matrix:")
    print(G_iteration)
    
    # Generate module name
    module_name = f"prbs{len(coefficients)}_width{args.width}_iter{args.times}"
    if args.suffix:
        module_name += f"_seed{args.suffix}"
    
    verilog_code = generate_verilog_from_matrix(G_iteration, module_name, coefficients,args.times)
    
    # Determine the output file path
    output_dir = args.output
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    output_file = os.path.join(output_dir, f"{module_name}.v")
    
    # Save to file
    with open(output_file, "w") as f:
        f.write(verilog_code)
    
    print(f"Verilog code saved to {output_file}")

if __name__ == "__main__":
    main()